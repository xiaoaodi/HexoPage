<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>C++11智能指针</title>
    <url>/HexoPage/2022/03/16/C++11%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/</url>
    <content><![CDATA[<h2 id="C-11-智能指针-shared-ptr-unique-ptr-weak-ptr"><a href="#C-11-智能指针-shared-ptr-unique-ptr-weak-ptr" class="headerlink" title="C++11 智能指针  shared_ptr unique_ptr weak_ptr"></a>C++11 智能指针  shared_ptr unique_ptr weak_ptr</h2><p>​    相信大家在编程的过程中，或多或少都遇到过内存泄漏的情况，指针的对象管理不当是造成内存泄漏的重要原因之一。 在C++中没有像java中的垃圾回收机制，自己在分配内存new和delete或者malloc和free总是配套使用的，但是我们有时从接口拿到的对象，或者是在某一个函数new了对象等，经过其他的问题处理，我们就忘记了我们在前面new了对象，导致内存泄漏。</p>
<p>为了处理前面的问题,C++11提供了三种智能指针：</p>
<p>​    1&gt; std::shared_ptr：共享的智能指针</p>
<p>​    2&gt;std::unique_ptr:  独占的智能指针</p>
<p>​    3&gt;std::weak_ptr：弱引用的智能指针，它不共享指针，不能操作资源，是用来监视 shared_ptr 的</p>
<p>使用这些智能指针只需引用<memory>头文件即可,智能指针的核心实现技术就是引用计数,每次你去使用它,内部的引用就会自动加1,每次析构引用减一,当为0时,删除在堆中分配的内存。</p>
<h2 id="1-shared-ptr-的初始化"><a href="#1-shared-ptr-的初始化" class="headerlink" title="1.shared_ptr 的初始化"></a>1.shared_ptr 的初始化</h2><p>​        我们知道共享指针shared_ptr是一个模板类,可以使用多个智能指针同时去管理一块有效的内存,进行初始化常用的三种方式:通过构造函数、std::make_shared 辅助函数以及 reset 方法。共享智能指针对象初始化完毕之后就指向了要管理的那块堆内存，如果想要查看当前有多少个智能指针同时管理着这块内存可以使用共享智能指针提供的一个成员函数 use_count，函数原型如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 管理当前对象的 shared_ptr 实例数量，或若无被管理对象则为 0。</span><br><span class="hljs-function"><span class="hljs-type">long</span> <span class="hljs-title">use_count</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> <span class="hljs-keyword">noexcept</span></span>;<br></code></pre></td></tr></table></figure>

<h4 id="1-1构造函数初始化"><a href="#1-1构造函数初始化" class="headerlink" title="1.1构造函数初始化"></a>1.1构造函数初始化</h4><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// shared_ptr&lt;T&gt; 类模板中，提供了多种实用的构造函数, 语法格式如下:</span><br>std::shared_ptr&lt;T&gt; 智能指针名字(创建堆内存);<br></code></pre></td></tr></table></figure>

<p>实现的代码如下:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 使用智能指针管理一块 int 型的堆内存</span><br>    <span class="hljs-function">shared_ptr&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">ptr1</span><span class="hljs-params">(<span class="hljs-keyword">new</span> <span class="hljs-type">int</span>(<span class="hljs-number">520</span>))</span></span>;<br>    cout &lt;&lt; <span class="hljs-string">&quot;ptr1管理的内存引用计数: &quot;</span> &lt;&lt; ptr1.<span class="hljs-built_in">use_count</span>() &lt;&lt; endl;<br>    <span class="hljs-comment">// 使用智能指针管理一块字符数组对应的堆内存</span><br>    <span class="hljs-function">shared_ptr&lt;<span class="hljs-type">char</span>&gt; <span class="hljs-title">ptr2</span><span class="hljs-params">(<span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[<span class="hljs-number">12</span>])</span></span>;<br>    cout &lt;&lt; <span class="hljs-string">&quot;ptr2管理的内存引用计数: &quot;</span> &lt;&lt; ptr2.<span class="hljs-built_in">use_count</span>() &lt;&lt; endl;<br>    <span class="hljs-comment">// 创建智能指针对象, 不管理任何内存</span><br>    shared_ptr&lt;<span class="hljs-type">int</span>&gt; ptr3;<br>    cout &lt;&lt; <span class="hljs-string">&quot;ptr3管理的内存引用计数: &quot;</span> &lt;&lt; ptr3.<span class="hljs-built_in">use_count</span>() &lt;&lt; endl;<br>    <span class="hljs-comment">// 创建智能指针对象, 初始化为空</span><br>    <span class="hljs-function">shared_ptr&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">ptr4</span><span class="hljs-params">(<span class="hljs-literal">nullptr</span>)</span></span>;<br>    cout &lt;&lt; <span class="hljs-string">&quot;ptr4管理的内存引用计数: &quot;</span> &lt;&lt; ptr4.<span class="hljs-built_in">use_count</span>() &lt;&lt; endl;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>&#125;<br></code></pre></td></tr></table></figure>

<p>注意:  如果智能指针被初始化了一块有效内存，那么这块内存的引用计数 + 1，如果智能指针没有被初始化或者被初始化为 nullptr 空指针，引用计数不会 + 1。另外，不要使用一个原始指针初始化多个 shared_ptr。</p>
<h4 id="1-2-通过拷贝和移动构造函数初始化"><a href="#1-2-通过拷贝和移动构造函数初始化" class="headerlink" title="1.2 通过拷贝和移动构造函数初始化"></a>1.2 通过拷贝和移动构造函数初始化</h4><p>​        当一个智能指针被初始化之后，就可以通过这个智能指针初始化其他新对象。在创建新对象的时候，对应的拷贝构造函数或者移动构造函数就被自动调用了。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 使用智能指针管理一块 int 型的堆内存, 内部引用计数为 1</span><br>    <span class="hljs-function">shared_ptr&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">ptr1</span><span class="hljs-params">(<span class="hljs-keyword">new</span> <span class="hljs-type">int</span>(<span class="hljs-number">520</span>))</span></span>;<br>    cout &lt;&lt; <span class="hljs-string">&quot;ptr1管理的内存引用计数: &quot;</span> &lt;&lt; ptr1.<span class="hljs-built_in">use_count</span>() &lt;&lt; endl;<br>    <span class="hljs-comment">//调用拷贝构造函数</span><br>    <span class="hljs-function">shared_ptr&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">ptr2</span><span class="hljs-params">(ptr1)</span></span>;<br>    cout &lt;&lt; <span class="hljs-string">&quot;ptr2管理的内存引用计数: &quot;</span> &lt;&lt; ptr2.<span class="hljs-built_in">use_count</span>() &lt;&lt; endl;<br>    shared_ptr&lt;<span class="hljs-type">int</span>&gt; ptr3 = ptr1;<br>    cout &lt;&lt; <span class="hljs-string">&quot;ptr3管理的内存引用计数: &quot;</span> &lt;&lt; ptr3.<span class="hljs-built_in">use_count</span>() &lt;&lt; endl;<br>    <span class="hljs-comment">//调用移动构造函数</span><br>    <span class="hljs-function">shared_ptr&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">ptr4</span><span class="hljs-params">(std::move(ptr1))</span></span>;<br>    cout &lt;&lt; <span class="hljs-string">&quot;ptr4管理的内存引用计数: &quot;</span> &lt;&lt; ptr4.<span class="hljs-built_in">use_count</span>() &lt;&lt; endl;<br>    std::shared_ptr&lt;<span class="hljs-type">int</span>&gt; ptr5 = std::<span class="hljs-built_in">move</span>(ptr2);<br>    cout &lt;&lt; <span class="hljs-string">&quot;ptr5管理的内存引用计数: &quot;</span> &lt;&lt; ptr5.<span class="hljs-built_in">use_count</span>() &lt;&lt; endl;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>&#125;<br></code></pre></td></tr></table></figure>

<p>注意:  如果使用拷贝的方式初始化共享智能指针对象，这两个对象会同时管理同一块堆内存，堆内存对应的引用计数也会增加；如果使用移动的方式初始智能指针对象，只是转让了内存的所有权，管理内存的对象并不会增加，因此内存的引用计数不会变化。</p>
<h4 id="1-3-通过-std-make-shared-初始化"><a href="#1-3-通过-std-make-shared-初始化" class="headerlink" title="1.3 通过 std::make_shared 初始化"></a>1.3 通过 std::make_shared 初始化</h4><p>通过 C++ 提供的 std::make_shared() 就可以完成内存对象的创建并将其初始化给智能指针，函数原型如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt; <span class="hljs-keyword">class</span> T, <span class="hljs-keyword">class</span>... Args &gt;</span><br><span class="hljs-function">shared_ptr&lt;T&gt; <span class="hljs-title">make_shared</span><span class="hljs-params">( Args&amp;&amp;... args )</span></span>;<br></code></pre></td></tr></table></figure>

<p>T：模板参数的数据类型<br>Args&amp;&amp;… args ：要初始化的数据，如果是通过 make_shared 创建对象，需按照构造函数的参数列表指定</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Test</span>() <br>    &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;construct Test...&quot;</span> &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-built_in">Test</span>(<span class="hljs-type">int</span> x) <br>    &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;construct Test, x = &quot;</span> &lt;&lt; x &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-built_in">Test</span>(string str) <br>    &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;construct Test, str = &quot;</span> &lt;&lt; str &lt;&lt; endl;<br>    &#125;<br>    ~<span class="hljs-built_in">Test</span>()<br>    &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;destruct Test ...&quot;</span> &lt;&lt; endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 使用智能指针管理一块 int 型的堆内存, 内部引用计数为 1</span><br>    shared_ptr&lt;<span class="hljs-type">int</span>&gt; ptr1 = <span class="hljs-built_in">make_shared</span>&lt;<span class="hljs-type">int</span>&gt;(<span class="hljs-number">520</span>);<br>    cout &lt;&lt; <span class="hljs-string">&quot;ptr1管理的内存引用计数: &quot;</span> &lt;&lt; ptr1.<span class="hljs-built_in">use_count</span>() &lt;&lt; endl;<br><br>    shared_ptr&lt;Test&gt; ptr2 = <span class="hljs-built_in">make_shared</span>&lt;Test&gt;();<br>    cout &lt;&lt; <span class="hljs-string">&quot;ptr2管理的内存引用计数: &quot;</span> &lt;&lt; ptr2.<span class="hljs-built_in">use_count</span>() &lt;&lt; endl;<br>    <br>    shared_ptr&lt;Test&gt; ptr3 = <span class="hljs-built_in">make_shared</span>&lt;Test&gt;(<span class="hljs-number">520</span>);<br>    cout &lt;&lt; <span class="hljs-string">&quot;ptr3管理的内存引用计数: &quot;</span> &lt;&lt; ptr3.<span class="hljs-built_in">use_count</span>() &lt;&lt; endl;<br>    <br>    shared_ptr&lt;Test&gt; ptr4 = <span class="hljs-built_in">make_shared</span>&lt;Test&gt;(<span class="hljs-string">&quot;我是要成为海贼王的男人!!!&quot;</span>);<br>    cout &lt;&lt; <span class="hljs-string">&quot;ptr4管理的内存引用计数: &quot;</span> &lt;&lt; ptr4.<span class="hljs-built_in">use_count</span>() &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>&#125;<br></code></pre></td></tr></table></figure>

<p>注意:使用 std::make_shared() 模板函数可以完成内存地址的创建，并将最终得到的内存地址传递给共享智能指针对象管理。如果申请的内存是普通类型，通过函数的（）可完成地址的初始化，如果要创建一个类对象，函数的（）内部需要指定构造对象需要的参数，也就是类构造函数的参数。</p>
<h4 id="1-4-通过-reset-方法初始化"><a href="#1-4-通过-reset-方法初始化" class="headerlink" title="1.4 通过 reset 方法初始化"></a>1.4 通过 reset 方法初始化</h4><p>​        共享智能指针类提供的 std::shared_ptr::reset 方法函数原型如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">reset</span><span class="hljs-params">()</span> <span class="hljs-keyword">noexcept</span></span>;<br><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt; <span class="hljs-keyword">class</span> Y &gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">reset</span><span class="hljs-params">( Y* ptr )</span></span>;<br><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt; <span class="hljs-keyword">class</span> Y, <span class="hljs-keyword">class</span> Deleter &gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">reset</span><span class="hljs-params">( Y* ptr, Deleter d )</span></span>;<br><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt; <span class="hljs-keyword">class</span> Y, <span class="hljs-keyword">class</span> Deleter, <span class="hljs-keyword">class</span> Alloc &gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">reset</span><span class="hljs-params">( Y* ptr, Deleter d, Alloc alloc )</span></span>;<br></code></pre></td></tr></table></figure>

<p>ptr：指向要取得所有权的对象的指针<br>d：指向要取得所有权的对象的指针<br>aloc：内部存储所用的分配器</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 使用智能指针管理一块 int 型的堆内存, 内部引用计数为 1</span><br>    shared_ptr&lt;<span class="hljs-type">int</span>&gt; ptr1 = <span class="hljs-built_in">make_shared</span>&lt;<span class="hljs-type">int</span>&gt;(<span class="hljs-number">520</span>);<br>    shared_ptr&lt;<span class="hljs-type">int</span>&gt; ptr2 = ptr1;<br>    shared_ptr&lt;<span class="hljs-type">int</span>&gt; ptr3 = ptr1;<br>    shared_ptr&lt;<span class="hljs-type">int</span>&gt; ptr4 = ptr1;<br>    cout &lt;&lt; <span class="hljs-string">&quot;ptr1管理的内存引用计数: &quot;</span> &lt;&lt; ptr1.<span class="hljs-built_in">use_count</span>() &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;ptr2管理的内存引用计数: &quot;</span> &lt;&lt; ptr2.<span class="hljs-built_in">use_count</span>() &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;ptr3管理的内存引用计数: &quot;</span> &lt;&lt; ptr3.<span class="hljs-built_in">use_count</span>() &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;ptr4管理的内存引用计数: &quot;</span> &lt;&lt; ptr4.<span class="hljs-built_in">use_count</span>() &lt;&lt; endl;<br><br>    ptr4.<span class="hljs-built_in">reset</span>();<br>    cout &lt;&lt; <span class="hljs-string">&quot;ptr1管理的内存引用计数: &quot;</span> &lt;&lt; ptr1.<span class="hljs-built_in">use_count</span>() &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;ptr2管理的内存引用计数: &quot;</span> &lt;&lt; ptr2.<span class="hljs-built_in">use_count</span>() &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;ptr3管理的内存引用计数: &quot;</span> &lt;&lt; ptr3.<span class="hljs-built_in">use_count</span>() &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;ptr4管理的内存引用计数: &quot;</span> &lt;&lt; ptr4.<span class="hljs-built_in">use_count</span>() &lt;&lt; endl;<br>    <br>    shared_ptr&lt;<span class="hljs-type">int</span>&gt; ptr5;<br>    ptr5.<span class="hljs-built_in">reset</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>(<span class="hljs-number">250</span>));<br>    cout &lt;&lt; <span class="hljs-string">&quot;ptr5管理的内存引用计数: &quot;</span> &lt;&lt; ptr5.<span class="hljs-built_in">use_count</span>() &lt;&lt; endl;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>&#125;<br></code></pre></td></tr></table></figure>

<p>注意: 对于一个未初始化的共享智能指针，可以通过 reset 方法来初始化，当智能指针中有值的时候，调用 reset 会使引用计数减 1。</p>
<h4 id="1-5-获取原始指针"><a href="#1-5-获取原始指针" class="headerlink" title="1.5 获取原始指针"></a>1.5 获取原始指针</h4><p>对应基础数据类型来说，通过操作智能指针和操作智能指针管理的内存效果是一样的，可以直接完成数据的读写。但是如果共享智能指针管理的是一个对象，那么就需要取出原始内存的地址再操作，可以调用共享智能指针类提供的 get () 方法得到原始地址，其函数原型如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function">T* <span class="hljs-title">get</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> <span class="hljs-keyword">noexcept</span></span>;<br></code></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> len = <span class="hljs-number">128</span>;<br>    <span class="hljs-function">shared_ptr&lt;<span class="hljs-type">char</span>&gt; <span class="hljs-title">ptr</span><span class="hljs-params">(<span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[len])</span></span>;<br>    <span class="hljs-comment">// 得到指针的原始地址</span><br>    <span class="hljs-type">char</span>* add = ptr.<span class="hljs-built_in">get</span>();<br>    <span class="hljs-built_in">memset</span>(add, <span class="hljs-number">0</span>, len);<br>    <span class="hljs-built_in">strcpy</span>(add, <span class="hljs-string">&quot;我是要成为海贼王的男人!!!&quot;</span>);<br>    cout &lt;&lt; <span class="hljs-string">&quot;string: &quot;</span> &lt;&lt; add &lt;&lt; endl;<br>    <br><br>    <span class="hljs-function">shared_ptr&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">p</span><span class="hljs-params">(<span class="hljs-keyword">new</span> <span class="hljs-type">int</span>)</span></span>;<br>    *p = <span class="hljs-number">100</span>;<br>    cout &lt;&lt; *p.<span class="hljs-built_in">get</span>() &lt;&lt; <span class="hljs-string">&quot;  &quot;</span> &lt;&lt; *p &lt;&lt; endl;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="1-6指定删除器"><a href="#1-6指定删除器" class="headerlink" title="1. 6指定删除器"></a>1. 6指定删除器</h4><p>当智能指针管理的内存对应的引用计数变为 0 的时候，这块内存就会被智能指针析构掉了。另外，我们在初始化智能指针的时候也可以自己指定删除动作，这个删除操作对应的函数被称之为删除器，这个删除器函数本质是一个回调函数，我们只需要进行实现，其调用是由智能指针完成的。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-comment">// 自定义删除器函数，释放int型内存</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">deleteIntPtr</span><span class="hljs-params">(<span class="hljs-type">int</span>* p)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">delete</span> p;<br>    cout &lt;&lt; <span class="hljs-string">&quot;int 型内存被释放了...&quot;</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-function">shared_ptr&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">ptr</span><span class="hljs-params">(<span class="hljs-keyword">new</span> <span class="hljs-type">int</span>(<span class="hljs-number">250</span>), deleteIntPtr)</span></span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>删除器函数也可以是 lambda 表达式，因此代码也可以写成下面这样：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-function">shared_ptr&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">ptr</span><span class="hljs-params">(<span class="hljs-keyword">new</span> <span class="hljs-type">int</span>(<span class="hljs-number">250</span>), [](<span class="hljs-type">int</span>* p) &#123;<span class="hljs-keyword">delete</span> p; &#125;)</span></span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>在上面的代码中，lambda表达式的参数就是智能指针管理的内存的地址，有了这个地址之后函数体内部就可以完成删除操作了。</p>
<p>在 C++11 中使用 shared_ptr 管理动态数组时，需要指定删除器，因为 std::shared_ptr的默认删除器不支持数组对象，具体的处理代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-function">shared_ptr&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">ptr</span><span class="hljs-params">(<span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[<span class="hljs-number">10</span>], [](<span class="hljs-type">int</span>* p) &#123;<span class="hljs-keyword">delete</span>[]p; &#125;)</span></span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>在删除数组内存时，除了自己编写删除器，也可以使用 C++ 提供的 std::default_delete<T>() 函数作为删除器，这个函数内部的删除功能也是通过调用 delete 来实现的，要释放什么类型的内存就将模板类型 T 指定为什么类型即可。具体处理代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-function">shared_ptr&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">ptr</span><span class="hljs-params">(<span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[<span class="hljs-number">10</span>], default_delete&lt;<span class="hljs-type">int</span>[]&gt;())</span></span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>另外，我们还可以自己封装一个 make_shared_array 方法来让 shared_ptr 支持数组，代码如下:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-function">shared_ptr&lt;T&gt; <span class="hljs-title">make_share_array</span><span class="hljs-params">(<span class="hljs-type">size_t</span> size)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 返回匿名对象</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">shared_ptr</span>&lt;T&gt;(<span class="hljs-keyword">new</span> T[size], <span class="hljs-built_in">default_delete</span>&lt;T[]&gt;());<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    shared_ptr&lt;<span class="hljs-type">int</span>&gt; ptr1 = <span class="hljs-built_in">make_share_array</span>&lt;<span class="hljs-type">int</span>&gt;(<span class="hljs-number">10</span>);<br>    cout &lt;&lt; ptr1.<span class="hljs-built_in">use_count</span>() &lt;&lt; endl;<br>    shared_ptr&lt;<span class="hljs-type">char</span>&gt; ptr2 = <span class="hljs-built_in">make_share_array</span>&lt;<span class="hljs-type">char</span>&gt;(<span class="hljs-number">128</span>);<br>    cout &lt;&lt; ptr2.<span class="hljs-built_in">use_count</span>() &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="2-unique-ptr指针的使用"><a href="#2-unique-ptr指针的使用" class="headerlink" title="2.unique_ptr指针的使用"></a>2.unique_ptr指针的使用</h2><h4 id="1-1unique-ptr初始化"><a href="#1-1unique-ptr初始化" class="headerlink" title="1.1unique_ptr初始化"></a>1.1unique_ptr初始化</h4><p>std::unique_ptr 是一个独占型的智能指针，它不允许其他的智能指针共享其内部的指针，可以通过它的构造函数初始化一个独占智能指针对象，但是不允许通过赋值将一个 unique_ptr 赋值给另一个 unique_ptr。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 通过构造函数初始化对象</span><br><span class="hljs-function">unique_ptr&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">ptr1</span><span class="hljs-params">(<span class="hljs-keyword">new</span> <span class="hljs-type">int</span>(<span class="hljs-number">10</span>))</span></span>;<br><span class="hljs-comment">// error, 不允许将一个unique_ptr赋值给另一个unique_ptr</span><br>unique_ptr&lt;<span class="hljs-type">int</span>&gt; ptr2 = ptr1;<br></code></pre></td></tr></table></figure>

<p>std::unique_ptr 不允许复制，但是可以通过函数返回给其他的 std::unique_ptr，还可以通过 std::move 来转译给其他的 std::unique_ptr，这样原始指针的所有权就被转移了，这个原始指针还是被独占的。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function">unique_ptr&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">func</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">unique_ptr</span>&lt;<span class="hljs-type">int</span>&gt;(<span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>(<span class="hljs-number">520</span>));<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 通过构造函数初始化</span><br>    <span class="hljs-function">unique_ptr&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">ptr1</span><span class="hljs-params">(<span class="hljs-keyword">new</span> <span class="hljs-type">int</span>(<span class="hljs-number">10</span>))</span></span>;<br>    <span class="hljs-comment">// 通过转移所有权的方式初始化</span><br>    unique_ptr&lt;<span class="hljs-type">int</span>&gt; ptr2 = <span class="hljs-built_in">move</span>(ptr1);<br>    unique_ptr&lt;<span class="hljs-type">int</span>&gt; ptr3 = <span class="hljs-built_in">func</span>();<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>&#125;<br></code></pre></td></tr></table></figure>

<p>unique_ptr 独占智能指针类也有一个 reset 方法，函数原型如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">reset</span><span class="hljs-params">( pointer ptr = pointer() )</span> <span class="hljs-keyword">noexcept</span></span>;<br></code></pre></td></tr></table></figure>

<p>使用 reset 方法可以让 unique_ptr 解除对原始内存的管理，也可以用来初始化一个独占的智能指针。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-function">unique_ptr&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">ptr1</span><span class="hljs-params">(<span class="hljs-keyword">new</span> <span class="hljs-type">int</span>(<span class="hljs-number">10</span>))</span></span>;<br>    unique_ptr&lt;<span class="hljs-type">int</span>&gt; ptr2 = <span class="hljs-built_in">move</span>(ptr1);<br><br>    ptr1.<span class="hljs-built_in">reset</span>();<br>    ptr2.<span class="hljs-built_in">reset</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>(<span class="hljs-number">250</span>));<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>&#125;<br></code></pre></td></tr></table></figure>

<p>​    ptr1.reset(); 解除对原始内存的管理<br>​    ptr2.reset(new int(250)); 重新指定智能指针管理的原始内存<br>如果想要获取独占智能指针管理的原始地址，可以调用 get () 方法，函数原型如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-function">unique_ptr&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">ptr1</span><span class="hljs-params">(<span class="hljs-keyword">new</span> <span class="hljs-type">int</span>(<span class="hljs-number">10</span>))</span></span>;<br>    unique_ptr&lt;<span class="hljs-type">int</span>&gt; ptr2 = <span class="hljs-built_in">move</span>(ptr1);<br><br>    ptr2.<span class="hljs-built_in">reset</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>(<span class="hljs-number">250</span>));<br>    cout &lt;&lt; *ptr2.<span class="hljs-built_in">get</span>() &lt;&lt; endl;	<span class="hljs-comment">// 得到内存地址中存储的实际数值 250</span><br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="1-2删除器"><a href="#1-2删除器" class="headerlink" title="1.2删除器"></a>1.2删除器</h4><p>unique_ptr 指定删除器和 shared_ptr 指定删除器是有区别的，unique_ptr 指定删除器的时候需要确定删除器的类型，所以不能像 shared_ptr 那样直接指定删除器，举例说明：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function">shared_ptr&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">ptr1</span><span class="hljs-params">(<span class="hljs-keyword">new</span> <span class="hljs-type">int</span>(<span class="hljs-number">10</span>), [](<span class="hljs-type">int</span>*p) &#123;<span class="hljs-keyword">delete</span> p; &#125;)</span></span>;	<span class="hljs-comment">// ok</span><br><span class="hljs-function">unique_ptr&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">ptr1</span><span class="hljs-params">(<span class="hljs-keyword">new</span> <span class="hljs-type">int</span>(<span class="hljs-number">10</span>), [](<span class="hljs-type">int</span>*p) &#123;<span class="hljs-keyword">delete</span> p; &#125;)</span></span>;	<span class="hljs-comment">// error</span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">using</span> func_ptr = <span class="hljs-built_in">void</span>(*)(<span class="hljs-type">int</span>*);<br>    <span class="hljs-function">unique_ptr&lt;<span class="hljs-type">int</span>, func_ptr&gt; <span class="hljs-title">ptr1</span><span class="hljs-params">(<span class="hljs-keyword">new</span> <span class="hljs-type">int</span>(<span class="hljs-number">10</span>), [](<span class="hljs-type">int</span>*p) &#123;<span class="hljs-keyword">delete</span> p; &#125;)</span></span>;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>&#125;<br></code></pre></td></tr></table></figure>

<p>在上面的代码中第 7 行，func_ptr 的类型和 lambda表达式的类型是一致的。在 lambda 表达式没有捕获任何变量的情况下是正确的，如果捕获了变量，编译时则会报错：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">using</span> func_ptr = <span class="hljs-built_in">void</span>(*)(<span class="hljs-type">int</span>*);<br>    <span class="hljs-function">unique_ptr&lt;<span class="hljs-type">int</span>, func_ptr&gt; <span class="hljs-title">ptr1</span><span class="hljs-params">(<span class="hljs-keyword">new</span> <span class="hljs-type">int</span>(<span class="hljs-number">10</span>), [&amp;](<span class="hljs-type">int</span>*p) &#123;<span class="hljs-keyword">delete</span> p; &#125;)</span></span>;	<span class="hljs-comment">// error</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>上面的代码中错误原因是这样的，在 lambda 表达式没有捕获任何外部变量时，可以直接转换为函数指针，一旦捕获了就无法转换了，如果想要让编译器成功通过编译，那么需要使用可调用对象包装器来处理声明的函数指针：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">using</span> func_ptr = <span class="hljs-built_in">void</span>()(<span class="hljs-type">int</span>);<br>    unique_ptr&lt;<span class="hljs-type">int</span>, function&lt;<span class="hljs-type">void</span>(<span class="hljs-type">int</span>)&gt;&gt; <span class="hljs-built_in">ptr1</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>(<span class="hljs-number">10</span>), [&amp;](intp) &#123;<span class="hljs-keyword">delete</span> p; &#125;);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br><br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="3-weak-ptr的使用"><a href="#3-weak-ptr的使用" class="headerlink" title="3.weak_ptr的使用"></a>3.weak_ptr的使用</h2><p>弱引用智能指针 std::weak_ptr 可以看做是 shared_ptr 的助手，它不管理 shared_ptr 内部的指针。std::weak_ptr 没有重载操作符 * 和 -&gt;，因为它不共享指针，不能操作资源，所以它的构造不会增加引用计数，析构也不会减少引用计数，它的主要作用就是作为一个旁观者监视 shared_ptr 中管理的资源是否存在。</p>
<h4 id="1-1-初始化"><a href="#1-1-初始化" class="headerlink" title="1.1 初始化"></a>1.1 初始化</h4><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 默认构造函数</span><br><span class="hljs-function"><span class="hljs-keyword">constexpr</span> <span class="hljs-title">weak_ptr</span><span class="hljs-params">()</span> <span class="hljs-keyword">noexcept</span></span>;<br><span class="hljs-comment">// 拷贝构造</span><br><span class="hljs-built_in">weak_ptr</span> (<span class="hljs-type">const</span> weak_ptr&amp; x) <span class="hljs-keyword">noexcept</span>;<br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">U</span>&gt; <span class="hljs-built_in">weak_ptr</span> (<span class="hljs-type">const</span> weak_ptr&lt;U&gt;&amp; x) <span class="hljs-keyword">noexcept</span>;<br><span class="hljs-comment">// 通过shared_ptr对象构造</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">U</span>&gt; <span class="hljs-built_in">weak_ptr</span> (<span class="hljs-type">const</span> shared_ptr&lt;U&gt;&amp; x) <span class="hljs-keyword">noexcept</span>;<br></code></pre></td></tr></table></figure>

<p>在 C++11 中，weak_ptr 的初始化可以通过以上提供的构造函数来完成初始化，具体使用方法如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-function">shared_ptr&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">sp</span><span class="hljs-params">(<span class="hljs-keyword">new</span> <span class="hljs-type">int</span>)</span></span>;<span class="hljs-comment">//weak_ptr&lt;int&gt; wp1; 构造了一个空 weak_ptr 对象</span><br><br>    weak_ptr&lt;<span class="hljs-type">int</span>&gt; wp1;<br>    <span class="hljs-function">weak_ptr&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">wp2</span><span class="hljs-params">(wp1)</span></span>;<span class="hljs-comment">//通过一个空 weak_ptr 对象构造了另一个空 weak_ptr 对象</span><br>    <span class="hljs-function">weak_ptr&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">wp3</span><span class="hljs-params">(sp)</span></span>;<span class="hljs-comment">//通过一个 shared_ptr 对象构造了一个可用的 weak_ptr 实例对象</span><br>    weak_ptr&lt;<span class="hljs-type">int</span>&gt; wp4;<br>    wp4 = sp;<span class="hljs-comment">//通过一个 shared_ptr 对象构造了一个可用的 weak_ptr 实例对象（这是一个隐式类型转换）</span><br>    weak_ptr&lt;<span class="hljs-type">int</span>&gt; wp5;<br>    wp5 = wp3;<span class="hljs-comment">//通过一个 weak_ptr 对象构造了一个可用的 weak_ptr 实例对象</span><br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="1-2-weak-ptr常用的函数"><a href="#1-2-weak-ptr常用的函数" class="headerlink" title="1.2 weak_ptr常用的函数"></a>1.2 weak_ptr常用的函数</h4><h5 id="1-2-1-use-count"><a href="#1-2-1-use-count" class="headerlink" title="1.2.1 use_count()"></a>1.2.1 use_count()</h5><p>通过调用 std::weak_ptr 类提供的 use_count() 方法可以获得当前所观测资源的引用计数，函数原型和测试代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 函数返回所监测的资源的引用计数</span><br><span class="hljs-function"><span class="hljs-type">long</span> <span class="hljs-type">int</span> <span class="hljs-title">use_count</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> <span class="hljs-keyword">noexcept</span></span>;<br><br>  <span class="hljs-function">shared_ptr&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">sp</span><span class="hljs-params">(<span class="hljs-keyword">new</span> <span class="hljs-type">int</span>)</span></span>;<br>  weak_ptr&lt;<span class="hljs-type">int</span>&gt; wp1;<br>  cout &lt;&lt; <span class="hljs-string">&quot;wp1: &quot;</span> &lt;&lt; wp1.<span class="hljs-built_in">use_count</span>() &lt;&lt; endl;<br></code></pre></td></tr></table></figure>

<h5 id="1-2-2-expired"><a href="#1-2-2-expired" class="headerlink" title="1.2.2 expired()"></a>1.2.2 expired()</h5><p>通过调用 std::weak_ptr 类提供的 expired() 方法来判断观测的资源是否已经被释放，函数原型和测试代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 返回true表示资源已经被释放, 返回false表示资源没有被释放</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">expired</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> <span class="hljs-keyword">noexcept</span></span>;<br><br><span class="hljs-function">shared_ptr&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">shared</span><span class="hljs-params">(<span class="hljs-keyword">new</span> <span class="hljs-type">int</span>(<span class="hljs-number">10</span>))</span></span>;<br><span class="hljs-function">weak_ptr&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">weak</span><span class="hljs-params">(shared)</span></span>;<br>cout &lt;&lt; <span class="hljs-string">&quot;1. weak &quot;</span> &lt;&lt; (weak.<span class="hljs-built_in">expired</span>() ? <span class="hljs-string">&quot;is&quot;</span> : <span class="hljs-string">&quot;is not&quot;</span>) &lt;&lt; <span class="hljs-string">&quot; expired&quot;</span> &lt;&lt; endl;<br></code></pre></td></tr></table></figure>

<p>weak_ptr 监测的就是 shared_ptr 管理的资源，当共享智能指针调用 shared.reset(); 之后管理的资源被释放，因此 weak.expired() 函数的结果返回 true，表示监测的资源已经不存在了</p>
<h5 id="1-2-3-lock"><a href="#1-2-3-lock" class="headerlink" title="1.2.3 lock()"></a>1.2.3 lock()</h5><p>通过调用 std::weak_ptr 类提供的 lock() 方法来获取管理所监测资源的 shared_ptr 对象，函数原型和测试代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function">shared_ptr&lt;element_type&gt; <span class="hljs-title">lock</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> <span class="hljs-keyword">noexcept</span></span>;<br><br>shared_ptr&lt;<span class="hljs-type">int</span>&gt; sp1, sp2;<br>weak_ptr&lt;<span class="hljs-type">int</span>&gt; wp;<br>sp1 = std::<span class="hljs-built_in">make_shared</span>&lt;<span class="hljs-type">int</span>&gt;(<span class="hljs-number">520</span>);<br>wp = sp1;<br>sp2 = wp.<span class="hljs-built_in">lock</span>();<br>cout &lt;&lt; <span class="hljs-string">&quot;use_count: &quot;</span> &lt;&lt; wp.<span class="hljs-built_in">use_count</span>() &lt;&lt; endl;<br>sp1.<span class="hljs-built_in">reset</span>();<br>cout &lt;&lt; <span class="hljs-string">&quot;use_count: &quot;</span> &lt;&lt; wp.<span class="hljs-built_in">use_count</span>() &lt;&lt; endl;<br><br></code></pre></td></tr></table></figure>

<h5 id="1-2-4-reset"><a href="#1-2-4-reset" class="headerlink" title="1.2.4 reset()"></a>1.2.4 reset()</h5><p>通过调用 std::weak_ptr 类提供的 reset() 方法来清空对象，使其不监测任何资源，函数原型和测试代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">reset</span><span class="hljs-params">()</span> <span class="hljs-keyword">noexcept</span></span>;<br><br><span class="hljs-function">shared_ptr&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">sp</span><span class="hljs-params">(<span class="hljs-keyword">new</span> <span class="hljs-type">int</span>(<span class="hljs-number">10</span>))</span></span>; <br><span class="hljs-function">weak_ptr&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">wp</span><span class="hljs-params">(sp)</span></span>;<br>cout &lt;&lt; <span class="hljs-string">&quot;1. wp &quot;</span> &lt;&lt; (wp.<span class="hljs-built_in">expired</span>() ? <span class="hljs-string">&quot;is&quot;</span> : <span class="hljs-string">&quot;is not&quot;</span>) &lt;&lt; <span class="hljs-string">&quot; expired&quot;</span> &lt;&lt; endl;<br>wp.<span class="hljs-built_in">reset</span>();<br>cout &lt;&lt; <span class="hljs-string">&quot;2. wp &quot;</span> &lt;&lt; (wp.<span class="hljs-built_in">expired</span>() ? <span class="hljs-string">&quot;is&quot;</span> : <span class="hljs-string">&quot;is not&quot;</span>) &lt;&lt; <span class="hljs-string">&quot; expired&quot;</span> &lt;&lt; endl;<br></code></pre></td></tr></table></figure>

<p>本文引用链接: <a href="https://subingwen.cn/cpp/weak_ptr/#3-%E8%A7%A3%E5%86%B3%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8%E9%97%AE%E9%A2%98">https://subingwen.cn/cpp/weak_ptr/#3-%E8%A7%A3%E5%86%B3%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8%E9%97%AE%E9%A2%98</a>  </p>
<p>非常好的技术文章希望有兴趣大家可以去学习</p>
]]></content>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/HexoPage/2022/03/16/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
</search>
